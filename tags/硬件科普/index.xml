<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>硬件科普 on QGAYE's Blog</title><link>https://qgaye.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE/</link><description>Recent content in 硬件科普 on QGAYE's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Jun 2022 22:16:46 +0800</lastBuildDate><atom:link href="https://qgaye.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>【硬件科普】全网最详细易懂的G Sync Freesync 垂直同步工作原理科普</title><link>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E6%98%93%E6%87%82%E7%9A%84g-sync-freesync-%E5%9E%82%E7%9B%B4%E5%90%8C%E6%AD%A5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A7%91%E6%99%AE/</link><pubDate>Sun, 05 Jun 2022 22:16:46 +0800</pubDate><guid>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E6%98%93%E6%87%82%E7%9A%84g-sync-freesync-%E5%9E%82%E7%9B%B4%E5%90%8C%E6%AD%A5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A7%91%E6%99%AE/</guid><description>【硬件科普】全网最详细易懂的G Sync Freesync 垂直同步工作原理科普
电脑中的帧是由显卡渲染出来的，60FPS意味着显卡在一秒钟内绘制了60张画面，然后发送给显示器显示
显示器在显示动态画面时都是利用逐行扫描完成的，显示器在收到一个完整帧后，会从屏幕的左上角开始一行一行进行绘制，直到绘制到右下角，这一幅完整的帧就被显示了出来，然后显示器会将扫描点从右下角挪回左上角，这个重置扫描点的过程称为Vblank
显示器的60Hz意味着显示器可以在一秒内进行完整的60次全画幅的逐行扫描，所以刷新率越高的屏幕所能表现出来的帧数也就越多
总结：帧数指的是显卡一秒内渲染好了多少张画面，而刷新率指显示器一秒内逐行扫描的次数，他俩不是相同的概念
帧缓存（Frame Buffer）：因为显示器的刷新率是固定的，但显卡输出的帧数会随着场景的复杂度变化，因此为了让变化的帧数和刷新率相匹配，就需要帧缓存
默认情况下有两个帧缓存，前缓存（FrontBuffer）和后缓存（BackBuffer），显卡在渲染好一帧画面时会先写入后缓存，等待后缓存写入完毕，前后缓存发生交换，后缓存变为前缓存，前缓存变为后缓存，整个过程称为帧传递（Buffer Swap），显示器会根据刷新率读取前缓存中画面绘制在显示器上
只要帧数和刷新率不匹配就会发生画面撕裂：
帧数 &amp;gt; 刷新率：当显示器渲染前缓存中画面时，显卡已经又绘制完成到后缓存中，发生前后缓存交换，显示器渲染了一半前缓存一半后缓存 帧数 &amp;lt; 刷新率：当显示器渲染完一次后，由于前缓存还未被交换，因此继续再次渲染同样的前缓存，在渲染过程中，显卡绘制完成，发生前后缓存交换，显示器又渲染了一半前缓存一半后缓存 垂直同步：强制帧传递（前后缓存交换）发生在显示器的Vblank阶段，即保证帧数和刷新率一致
显卡如果提前绘制好后缓存，显卡就必须空等着，直到显示器绘制完前缓存，因此打开垂直同步后，帧率会被锁定在显示器的最大刷新率下 显卡如果绘制慢与刷新率，那么显示器就只能再次刷新前一次的前缓存，直到Vblank阶段的后缓存绘制完毕，才能刷新出新画面，因此此时就会发生画面不流畅的现象（自适应垂直同步：帧数如果高于60帧，则打开垂直同步，如果低于60帧，则关闭垂直同步，立即刷新） 垂直同步的延迟问题：因为垂直同步下帧传递必须在Vblank阶段，即在显示器完整刷新完一次后，这就导致显卡已经绘制到后缓存中的画面，无法立刻反馈到屏幕上
快速垂直同步（无阻塞垂直同步）：通过三重缓冲，在前后缓存中添加中缓存，并允许中缓存和后缓存不停进行交替，于是显卡就可以不停绘制新画面到后缓存中，显卡就无须等着显示器，并且同时中缓存有着完整的一帧，来和前缓存进行替换，也就不会发生画面撕裂
快速垂直同步的问题：由于显卡的后缓存中很多帧都被复写抛弃了，导致帧和帧的间隔和运动巨大，会出现非常明显的帧生成时间不均匀导致的卡顿感
G-sync/Freesync（自适应显示器刷新率、VRR）：当显卡的输出帧低于显示器刷新率时，强制延长Vblank时间，让显示器持续显示上一帧画面，不进行任何操作，等显卡完成下一帧的图像渲染后再允许帧传递，以此来让显示器的刷新率去动态匹配显卡输出帧
G-sync和Freesync只能解决帧数与刷新率的撕裂现象，当帧数大于刷新率时还是会出现画面撕裂，因此打开G-sync和Freesync的同时，要么锁帧到小于显示器刷新率的2-4帧，要么打开垂直同步
垂直同步：显卡等显示器 VRR：显示器等显卡 G-sync和Freesync区别：
两者都是通过调整显示器的Vblank来调整刷新率，实现原理相同 G-sync是NVIDIA搞的，需要授权和收费，但因为需要授权，因此实现效果都好于Freesync Freesync是免费的标准，是DP接口中一个附加协议</description></item><item><title>【硬件科普】固态硬盘的缓存是干什么的？有缓存和无缓存有什么区别？</title><link>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E7%BC%93%E5%AD%98%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%E6%9C%89%E7%BC%93%E5%AD%98%E5%92%8C%E6%97%A0%E7%BC%93%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 04 Jun 2022 23:02:04 +0800</pubDate><guid>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E7%BC%93%E5%AD%98%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%E6%9C%89%E7%BC%93%E5%AD%98%E5%92%8C%E6%97%A0%E7%BC%93%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid><description>【硬件科普】固态硬盘的缓存是干什么的？有缓存和无缓存有什么区别？
固态硬盘主要结构：主控芯片、DRAM缓存、NAND闪存
固态硬盘写入数据时，数据经过 主控处理随后被放在NAND闪存颗粒中，读取数据时，主控会从FTL表中找到数据位置，然后从NAND颗粒中找到数据，之后通过M.2接口和PCIe总线发送给计算机其他配件
逻辑物理映射表（FTL表）：主控在写入时记录写入的NAND颗粒的具体位置（哪个晶片、哪个区、哪个块、哪个页），下次数据读取时通过FTL表找到数据的具体存储位置进行数据读取，一般来说1G容量的NAND颗粒需要1MB的FTL表缓存
FTL表存放位置：
DRAM足够大时，可以全部存放在DRAM中 厂家为了节省成本，DRAM不够时（或者直接较小缓存集成在主控中），就会将常用文件的FTL表放在DRAM中，剩余的放在NAND颗粒中 无缓存方案，采用HMB技术，在启动时将一部分FTL表加载到内存中，通过PCIe高速通道来达到加速读取的功能 NAND颗粒由多层晶片（die chip）构成，每个die chip有两个区plane，它们共用一个地址解码器，每个区plane中由大量Block块组成
浮栅晶体管，其是可以存储电子的结构，因此也就是可以用来存储数据
SLC颗粒：每个浮栅晶体管只能存放1Bit数据，当浮栅晶体管中电子数大于3时认定为1，小于3时认定为0 MLC颗粒：每个浮栅晶体管可以存储2Bit数据，即根据浮栅晶体管中电子数量区间判定是00、01、10、11 TLC颗粒：每个浮栅晶体管可以存储3Bit数据，浮栅晶体管中每个数量的电子都对应一个数据，因此对电压的控制要求也更高
早期，固态硬盘的浮栅晶体管是平铺在晶圆上的，平面结构很浪费空间，为了提高数据密度，设计出了可以垂直叠放的浮栅晶体管，因此现在固态硬盘的颗粒都成为VNAND（Vertical）
由大量浮栅晶体管组成的长方体成为Block块，其中一面中一行称为Page页，通过地址解码器+位线解码器来选中页Page，因此硬盘读取的最小单位就是页Page
DRAM作用：
存储FTL表信息，用于加速主控查找数据的具体位置 缓解写放大：固态硬盘最小擦除单位是块，最小写入单位是页，因此当所有页都占满时，就需要将不足一页的数据进行合并，然后擦除块在进行写入，这会加速硬盘的寿命磨损，因此主控会在写入数据时先将数据写入DRAM中，等存满一页后再写入 SLC Cache：当向硬盘持续写入数据时，会发现前一段时间写入速度较快（缓内速度），然后速度会变慢（缓外速度）
SLC的浮栅晶体管因为只需要维持两种状态，因此擦除或写入电子只需要极高或极低两种电压，相较于MLC或TLC，不需要精确控制电压，因此速度会更快，并且由于SLC只能写入1Bit，因此多Bit写入时所有Bit都是并行的，而MLC或TLC至少有2个或3个Bit是必须串行写入的，毫无疑问SLC速度会更快
对于一个浮栅晶体管而言，其是SLC还是TLC完全由主控的读写策略决定，因此主控可以将NAND中一部分浮栅晶体管模拟成SLC（SLC Cache），在写入数据时先将数据写入模拟成SLC的部分，然后再把这部分缓存写入TLC中，但因为SLC Cache是需要占用原来的TLC空间的，随着硬盘内数据的增加，SLC Cache的空间就会减少（并且如果把整个硬盘都模拟成SLC，那么硬盘的可用容量就会缩减成1/3），因此随着写入量的增加写入速度就会变慢
绝大多数情况下，都很少会进行超出SLC Cache范围之外的数据写入，因此用到的往往都是SLC的真实写入性能
由于SLC能存储的Bit数只有TLC的1/3，因此SLC Cache的存在无形会提高擦写次数，有些可以通过配置独立SLC区域，来避免小文件的写放大问题</description></item><item><title>【硬件科普】全网最简洁易懂的OLED与LCD屏幕工作原理与优劣科普</title><link>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E5%85%A8%E7%BD%91%E6%9C%80%E7%AE%80%E6%B4%81%E6%98%93%E6%87%82%E7%9A%84oled%E4%B8%8Elcd%E5%B1%8F%E5%B9%95%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8A%A3%E7%A7%91%E6%99%AE/</link><pubDate>Sat, 09 Apr 2022 17:08:45 +0800</pubDate><guid>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E5%85%A8%E7%BD%91%E6%9C%80%E7%AE%80%E6%B4%81%E6%98%93%E6%87%82%E7%9A%84oled%E4%B8%8Elcd%E5%B1%8F%E5%B9%95%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8A%A3%E7%A7%91%E6%99%AE/</guid><description>【硬件科普】全网最简洁易懂的OLED与LCD屏幕工作原理与优劣科普
OLED（Organic Light-Emitting Diode）有机发光二极管
OLED优点：
相较于LCD不需要整个背光层都亮起，OLED每个像素点都是独立发光的 LCD的液晶分子偏转不能做到完全闭合，因此在显式黑的时候也是有些微的白光射出去，所以显式的是亮度大幅递减的灰色而不是纯正的黑色，而OLED直接控制不发光即可，即纯正的黑色 LCD屏幕和边框的衔接处，背光层的背光很容易漏出去，即漏光，而OLED没有背光层也就没有漏光问题 LCD响应速度取决于液晶层偏转的速度，而液晶层的偏转与温度有关，温度越低偏转的速度越慢，LCD屏幕在低温下会出现非常明显的拖影，而OLED因为没有液晶层也就不存在低温问题，但OLED也有响应时间，但总体比LCD还是快 LCD需要背光层，液晶层，再加上偏光片，因此LCD的厚度比OLED厚很多 LCD需要整块背光层发亮，而OLED可以控制每个像素点开关，因此比LCD省电 OLED缺点：
OLED电压是直接施加在自发光二极管上，相较于LCD则是电压施加在不发光的液晶层上，此外有机物也比无机物更易老化，所以有机物加频繁的电子迁移自发光直接导致OLED屏幕寿命短于LCD屏幕 LCD背光层是一整块，要老化所有像素一起老化，所以不宜察觉，而OLED是每个像素独立发光的，屏幕不同区域使用程度的不同老化的程度也不同，比如蓝色的二极管因为蓝光能量强就更易老化，那么在显式纯色时这块蓝色就显式的暗一些，导致出现残影，这就是烧屏（烧屏最早出现在等离子显示器上） DC调光：直接控制电压来改变灯的亮度。PWM调光：调整占空比来控制亮度，就是1ms中一段时间发光，另一端时间不发光，那么总体来看这1ms的亮度就能够调节了，因此PWM调光必然会出现频闪，尤其是低亮度下，1ms能大部分时间要不发光来调低亮度，那么肉眼就极易察觉到频闪，又因为OLED有机二极管极易老化，因此只能使用低频PWM后不能使用高频PWM（对OLED的有机自发光层进行了改良，显著的将蓝光波长向右偏移，降低了OLED屏幕对人眼的伤害） LCD屏幕中RGB三个子像素无论大小还是个数都是相同的，而OLED中因为技术原因，蓝色二极管寿命更低，而且有机二极管成本高，所以采用的是钻石排列（RGBG），红蓝像素比绿色像素多，并且是45度排列而不是水平排列，所以OLED屏幕的实际PPI（像素密度）大概只有LCD的81% mirco-LED：将LCD中像素下红绿蓝三个子像素都做成单独发光的LED灯珠，即可以直接控制LED灯珠亮度来控制像素的颜色，也就是RGB排列下的OLED，且发光材料由有机二极管变为LED灯珠，其兼具了LCD和OLED的所有优点
mini-LED：将LCD中整个背光层进行了切割，分成多个背光区，但液晶层还是存在，所以还是存在LCD的缺点，只能在一定范围内提高局部亮度对比度</description></item><item><title>【硬件科普】显示器的1ms响应时间其实是个骗局？详解显示器灰阶响应时间</title><link>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%841ms%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%AA%E9%AA%97%E5%B1%80%E8%AF%A6%E8%A7%A3%E6%98%BE%E7%A4%BA%E5%99%A8%E7%81%B0%E9%98%B6%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/</link><pubDate>Sat, 09 Apr 2022 17:01:19 +0800</pubDate><guid>https://qgaye.github.io/posts/%E7%A1%AC%E4%BB%B6%E8%8C%B6%E8%B0%88/%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%841ms%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%AA%E9%AA%97%E5%B1%80%E8%AF%A6%E8%A7%A3%E6%98%BE%E7%A4%BA%E5%99%A8%E7%81%B0%E9%98%B6%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/</guid><description>【硬件科普】显示器的1ms响应时间其实是个骗局？详解显示器灰阶响应时间
LCD屏幕工作原理：最底下的背光层负责发射白光，施加电压驱使中间的液晶层发生偏转，使得遮挡一部分的光不被射出，最上层是红绿蓝三原色的彩色滤光片，背光层发射的白光通过滤光片后成为了一个彩色像素点，只需要控制电压大小，就可以控制液晶层的偏转角度，进而控制红绿蓝子像素的亮度，最终红绿蓝三个子像素亮度决定了这个像素的颜色亮度
LCD屏幕颜色的切换是通过控制液晶层的偏转来完成的，液晶层偏转的速度决定了LCD屏幕的响应时间
黑白响应时间：液晶层偏转角度完全打开就是白色，完全关闭就是黑色，虽然黑白颜色间的切换是液晶层偏转的最大角度，花费的时间看似也应该最长，但事实上因为黑白切换是两个极端，因此只需要直接给一个很高的电压来快速完成切换，而其他颜色间的切换则必须细致的调整电压，精确控制比快速控制更耗时
灰阶响应时间（Grey To Grey）：控制像素点亮度就需要传输代表亮度的信号，1bit就代表只有0和1两种亮度状态，8bit则代表有256种亮度状态，代表着亮度间过度的更平滑细腻，但同时亮度变化信号就需要更大的8位。灰阶响应时间就是从某个亮度变化到另一个亮度所需的时间，相较于黑白响应时间，这更考验液晶分子偏转的精度和速度，也更符合平时的日常使用（但灰阶响应时间没有统一标准，从0到1或者从0到255都可以称作灰阶响应时间）
ULMB：在像素点切换颜色的过程中插入黑场来降低拖影。因为液晶分子在偏转的时候并不是瞬发的，而是有一个过程，也就是在偏转的过程中会出现两个颜色的中间的过渡色，ULMB就是在两个颜色的切换过程中关闭背光 ，此时这个像素就是黑色的，等待像素点完全切换到另一个颜色后再打开背光。因为切换过程会关闭背光，因此开启ULMB后屏幕亮度会降低，此外反复的开关背光会带来频闪，再者有些画面就是需要连续的色彩过度，开启ULMB会影响使用体验
OD（OverDrive）：OD就是给液晶分子加压，用更高的电压使液晶分子偏转的更快一点，适度的加压确实可以加快屏幕的响应时间，fast ips和nano ips都是通过OD实现的。但是高压使得液晶分子到达设定的偏转角度后不能马上停下，而是会继续偏转一段距离到另一个颜色后再偏转回来，这个现象叫做信号过冲（OverShoot），会带来伪影或鬼影的问题
拖影：像素来不及改变颜色，观感上是上一幅画面的颜色残留
鬼影：像素点到达目标颜色后继续偏转，观感上是颜色和原画面颜色不同</description></item></channel></rss>